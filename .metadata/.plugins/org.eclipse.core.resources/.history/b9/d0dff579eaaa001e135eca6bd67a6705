package com.osc.websocket.service.impl;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.grpc.user.UserServiceGrpc.UserServiceBlockingStub;
import com.grpc.user.cart.findIsProductAvailableRequest;
import com.grpc.user.cart.findIsProductAvailableResponse;
import com.grpc.user.cart.findIsProductAvailableServiceGrpc.findIsProductAvailableServiceBlockingStub;
import com.osc.websocket.Utils;
import com.osc.websocket.entities.Product;
import com.osc.websocket.payload.Category;
import com.osc.websocket.payload.DataObject;
import com.osc.websocket.payload.DataStore;
import com.osc.websocket.payload.FeaturedProduct;
import com.osc.websocket.payload.ProductDto;
import com.osc.websocket.payload.Response;
import com.osc.websocket.repository.ProductRepository;
import com.osc.websocket.service.ProductService;

import net.devh.boot.grpc.client.inject.GrpcClient;

@Service
public class ProductServiceImpl implements ProductService{
	
	@GrpcClient("cart")
	findIsProductAvailableServiceBlockingStub blockingStub;

	@Autowired
	ProductRepository repository;

	@Autowired
	ModelMapper modelMapper;

	@Override
	public Response findNoViewingHistoryRecord() {

		DataObject dataObject = new DataObject();

		DataStore dataStore = new DataStore();
		dataStore.setCategories(findAllCategories());
		dataStore.setType("Category");
		dataObject.getData().add(dataStore);

		dataStore = new DataStore();
		dataStore.setFeaturedProducts(featureProductList());
		dataStore.setType("Featured Products");
		dataObject.getData().add(dataStore);

		Response response = new Response();
		response.setCode(200);
		response.setDataObject(dataObject);

		return response;
	}

	@Override
	public Response findUserHadHistoryRecord(Map<String, ProductDto> recentlyViewedProductMap) {

		DataObject dataObject = new DataObject();

		DataStore dataStore = new DataStore();
		dataStore.setRecentlyViewedProducts(recentlyViewedProductMap.values());
		dataStore.setType("Recently Viewed Products");
		dataObject.getData().add(dataStore);

		dataStore = new DataStore();
		dataStore.setSimilarProducts(findSimilarProductsForRecentlyViewed(recentlyViewedProductMap).values());
		dataStore.setType("Similar Products");
		dataObject.getData().add(dataStore);

		dataStore = new DataStore();
		dataStore.setCategories(findAllCategories());
		dataStore.setType("Categories");
		dataObject.getData().add(dataStore);

		Response response = new Response();
		response.setCode(200);
		response.setDataObject(dataObject);

		return response;
	}

	@Override
	public List<Category> findAllCategories() {

		List<Object[]> categoryObjList = repository.findCategories();

		return categoryObjList.stream()
				.map(c -> new Category(c[0]+"", c[1]+"",c[2]+""))
				.collect(Collectors.toList());
	}

	private List<FeaturedProduct> featureProductList() {

		List<Product> productList = repository.findAllByOrderByViewCountDescProductIdAsc();

		return productList.stream().map( i ->

		new FeaturedProduct(i.getProductId(),i.getCategory().getCategoryId(),i.getProductName(),i.getProductPrice())

				).collect(Collectors.toList());
	}

	@Override
	public ProductDto findByProductId(String id) {

		List<Object[]> productArr =  repository.findProductAndViewCountRank(id);

		Product product = (Product)productArr.get(0)[0];
		Long rank = (Long)productArr.get(0)[1];

		if(product != null) {
			ProductDto dto = modelMapper.map(product, ProductDto.class);
			dto.setRank(rank);
			return dto;
		}

		return null;
	}

	@Override
	public List<ProductDto> findByCategoryId(char caegoryId) {

		List<Product> similarProductList = repository.findSimilarProducts(caegoryId);

		if(Utils.isNotEmpty(similarProductList)) {
			return similarProductList.stream().map(i->modelMapper.map(i, ProductDto.class)).collect(Collectors.toList());
		}

		return null;
	}

	private Map<String, ProductDto> findSimilarProductsForRecentlyViewed(Map<String, ProductDto> recentlyViewedMap){

		Map<String, ProductDto> similarProductMap = new LinkedHashMap<>(6);

		int offset=0;
		for (Map.Entry<String, ProductDto> entry : recentlyViewedMap.entrySet()) {

			ProductDto product = entry.getValue();

			if(product.getRank() == 1) {
				offset = 1;
			}else {
				offset = 0;
			}

			ProductDto similarProducts = getSimilarProducts(product, recentlyViewedMap,similarProductMap, offset);

			similarProductMap.put(similarProducts.getProductId(), similarProducts);
		}

		if(recentlyViewedMap.size()<6) {

			int size = 6 - recentlyViewedMap.size();
			boolean isTopProduct = recentlyViewedMap.values().stream().findFirst().get().getRank() == 1 ? true : false;

			for(int i = 1 ; i<=size; i++) {

				if(isTopProduct) {
					offset = 1;
				}else {
					offset = 0;
				}

				ProductDto productDto = similarProductMap.values().stream().findFirst().get();

				ProductDto similarProducts = getSimilarProducts(productDto, recentlyViewedMap,similarProductMap, offset);

				similarProductMap.put(similarProducts.getProductId(), similarProducts);
			}

		}

		return similarProductMap;
	}

	private ProductDto getSimilarProducts(ProductDto product,Map<String, ProductDto> recentlyViewedMap,Map<String, ProductDto> similarProductMap,int Offset) {

		List<Product> findWithOffsetAndLimit = null;

		findWithOffsetAndLimit = repository.findWithOffsetAndLimit(product.getCategory().getCategoryId(), PageRequest.of(Offset, 1));

		String productId = findWithOffsetAndLimit.get(0).getProductId();

		if(recentlyViewedMap.containsKey(productId) || similarProductMap.containsKey(productId)) {
			return getSimilarProducts(product, recentlyViewedMap, similarProductMap, Offset+1);
		}

		return modelMapper.map(findWithOffsetAndLimit.get(0), ProductDto.class);
	}

	@Override
	public List<ProductDto> findByCategoryId(char caegoryId, String filter) {
		
		List<Product> productList = null;
		
		if(filter != null && filter.equals("LH"))
			productList = repository.findByCategoryId(caegoryId, Sort.by(Sort.Direction.ASC, "productPrice"));
		
		if(filter != null && filter.equals("HL"))
			productList = repository.findByCategoryId(caegoryId, Sort.by(Sort.Direction.DESC, "productPrice"));
		
		if(filter != null && filter.equals("P"))
			productList = repository.findByCategoryId(caegoryId, Sort.by(Sort.Direction.DESC, "viewCount"));
		
		if(filter != null && filter.equals("NF"))
			productList = repository.findByCategoryId(caegoryId, Sort.by(Sort.Direction.DESC, "viewCount"));

		return productList.stream()
                .map(product -> modelMapper.map(product, ProductDto.class))
                .collect(Collectors.toList());
	}

	public boolean findIsProductAlreadyAvailable(String jsonMessage) throws JsonMappingException, JsonProcessingException {
		
		Map<String, String> jsonMap = new ObjectMapper().readValue(jsonMessage, HashMap.class);
		
		findIsProductAvailableRequest request = findIsProductAvailableRequest.newBuilder()
												.setProdId(jsonMap.get("prodId"))
												.setUserId("userId")
												.build();
		
		findIsProductAvailableResponse productAvailabilityService = blockingStub.productAvailabilityService(request);
		
		return productAvailabilityService.getIsProductAvailable();
		
		return false;
	}


}
